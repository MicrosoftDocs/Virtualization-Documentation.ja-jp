---
title: Inter-Partition 通信
description: Inter-Partition 通信
keywords: hyper-v
author: alexgrest
ms.author: alegre
ms.date: 10/15/2020
ms.topic: reference
ms.prod: windows-10-hyperv
ms.openlocfilehash: 5773ca47af0d5967186af80330e6387772646107
ms.sourcegitcommit: d43632e3dc22e2b7a256b5c15fbb665c047de286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/16/2020
ms.locfileid: "92120916"
---
# <a name="inter-partition-communication"></a>Inter-Partition 通信

ハイパーバイザーは、1つのパーティションが別のパーティションと通信するための2つの簡単なメカニズムを提供します。つまり、メッセージとイベントです。 どちらの場合も、通知は SynIC (合成割り込みコントローラー) を使用して通知されます。

## <a name="synic-messages"></a>SynIC メッセージ

ハイパーバイザーは、単純なパーティション間通信機能を提供します。これにより、1つのパーティションから別のパーティションにパラメーター化されたメッセージを送信できるようになります。 (メッセージは非同期に送信されるため、通知されます)。転送先パーティションには、割り込みによってこのメッセージが到着したことが通知される場合があります。 メッセージは、 [HvCallPostMessage](hypercalls/HvCallPostMessage.md) ハイパーコールを使用して明示的に送信することも、ハイパーバイザーによって暗黙的に送信することもできます。

### <a name="messages"></a>メッセージ

メッセージが送信されると、ハイパーバイザーは解放されたメッセージバッファーを選択します。 使用可能なメッセージバッファーのセットは、メッセージの送信をトリガーしたイベントによって異なります。

ハイパーバイザーはメッセージバッファーを "使用中" としてマークし、メッセージの種類、ペイロードサイズ、および送信者に関する情報をメッセージヘッダーに入力します。 最後に、メッセージペイロードを入力します。 ペイロードの内容は、メッセージをトリガーしたイベントによって異なります。

次に、ハイパーバイザーはメッセージバッファーを受信メッセージキューに追加します。 受信メッセージキューは、メッセージの送信をトリガーしたイベントに依存します。 すべてのメッセージ型について、SINTx は暗黙的 (メッセージのインターセプトの場合)、明示的 (タイマーメッセージの場合)、またはポート ID (ゲストメッセージの場合) で指定されます。 ターゲット仮想プロセッサは、メッセージがエンキューされるときに、明示的に指定されるか、ハイパーバイザーによって選択されます。 SynIC または SIM ページが無効になっている仮想プロセッサは、潜在的なターゲットとは見なされません。 使用できるターゲットがない場合、ハイパーバイザーは操作を終了し、エラーを呼び出し元に返します。

その後、ハイパーバイザーは、ターゲット仮想プロセッサの [SIM ページ](#sim-page) 内の指定された SINTx メッセージスロットが空かどうかを判断します。 メッセージスロット内のメッセージの種類が HvMessageTypeNone (つまり、ゼロ) と等しい場合、メッセージスロットは空であると見なされます。 この場合、ハイパーバイザーはメッセージバッファーをデキューし、その内容を SIM ページ内のメッセージスロットにコピーします。 ハイパーバイザーは、メッセージに関連付けられているペイロードのバイト数のみをコピーする場合があります。 また、ハイパーバイザーは、指定された SINTx のエッジトリガー割り込みの生成を試みます。 APIC がソフトウェアによって無効になっている場合、または SINTx がマスクされている場合、割り込みは失われます。 この割り込みが到着すると、新しいメッセージが到着したことがゲストに通知されます。 SIM ページが無効になっている場合、または SIM ページ内のメッセージスロットが空でない場合、メッセージはキューに残り、割り込みは生成されません。

すべての固定優先順位割り込みと同様に、割り込みは、PPR (プロセスの優先順位レジスタ) が SINTx レジスタで指定されたベクターよりも小さく、割り込みが仮想プロセッサによってマスクされないようになるまで、仮想プロセッサによって確認されません (rFLAGS [IF] が1に設定されている場合)。

SINTx が同じ複数のメッセージバッファーを仮想プロセッサにキューに入れることができます。 この場合、ハイパーバイザーは最初のメッセージを配信し (つまり、SIM ページに書き込みます)、次の3つのイベントのいずれかが発生するまで、他のメッセージをキューに入れたままにします。

- 別のメッセージバッファーがキューに登録されています。
- このゲストは、APIC の EOI レジスタに書き込んで、"割り込みの終了" を示します。
- このゲストは、SynIC の [EOM register](#eom-register)に書き込むことによって、"メッセージの終わり" を示します。

この3つの場合、ハイパーバイザーは1つ以上のメッセージバッファーキューをスキャンし、追加のメッセージを配信しようとします。 また、ハイパーバイザーは、新しいメッセージが到着したことを示す、エッジによってトリガーされる割り込みの生成を試みます。

#### <a name="sim-page"></a>SIM ページ

SIM ページは、256バイトのメッセージの16要素配列で構成されています (「 [HV_MESSAGE](datatypes/HV_MESSAGE.md) データ構造」を参照してください)。 各配列要素 (メッセージスロットとも呼ばれます) は、単一の合成割り込みソース (SINTx) に対応します。 スロット内のメッセージのメッセージの種類が HvMessageTypeNone の場合、メッセージスロットは "空" と呼ばれます。

SIM ページのアドレスは、 [SIMP register](#simp-register)に指定されています。 SIM ページのアドレスは、各仮想プロセッサに対して一意である必要があります。 これらのページをプログラミングして、SIEF または SIM ページの他のインスタンスや、その他のオーバーレイページ (たとえば、ハイパーコールページ) と重複すると、未定義の動作が発生します。

仮想プロセッサによる SIM ページへの読み取りおよび書き込みアクセスは、RAM への読み取りおよび書き込みアクセスと同様に動作します。 ただし、ハイパーバイザーの SynIC 実装では、特定のイベントに応答してページにも書き込まれます。

仮想プロセッサの作成とリセット時に、SIM ページがゼロにクリアされます。

#### <a name="recommended-message-handling"></a>推奨されるメッセージ処理

SynIC メッセージ配信メカニズムは、対象パーティション内のメッセージの効率的な配信と受信に対応するように設計されています。 ターゲットパーティション内のメッセージ処理 ISR (interrupt service ルーチン) では、次の手順を実行することをお勧めします。

- SIM メッセージスロットに格納されているメッセージを確認します。
- メッセージの内容を別の場所にコピーし、メッセージスロット内のメッセージの種類を HvMessageTypeNone に設定します。
- APIC の EOI レジスタに書き込むことによって、ベクターの割り込みの終了を示します。
- メッセージによって暗黙的に処理されるアクションを実行します。

#### <a name="message-sources"></a>メッセージの送信元

メッセージの送信をトリガーできるイベントのクラスは次のとおりです。

- インターセプト: 仮想プロセッサの任意のインターセプトによって、親パーティションまたは上位の VTL のいずれかにメッセージが送信されます。
- タイマー: タイマーメカニズムによってメッセージが送信されます。 各仮想プロセッサに関連付けられた4つの専用タイマーメッセージバッファー (タイマーごとに1つ)。 受信メッセージキューは、タイマーがメッセージの送信をトリガーした仮想プロセッサの SINTx に属しています。
- ゲストメッセージ: ハイパーバイザーは、ゲスト間のパーティション間通信メカニズムとしてメッセージを渡すことをサポートします。 このセクションで定義されているインターフェイスを使用すると、あるゲストから別のゲストにメッセージを送信できます。 このクラスのメッセージに使用されるメッセージバッファーは、受信側のポートごとのゲストメッセージバッファーのプールから取得されます。

### <a name="message-buffers"></a>メッセージバッファー

メッセージバッファーは、受信者に配信されるまでメッセージを格納するために、内部的にハイパーバイザーに使用されます。 ハイパーバイザーは、いくつかのメッセージバッファーのセットを保持します。

#### <a name="guest-message-buffers"></a>ゲストメッセージバッファー

ハイパーバイザーは、各ポートに対して一連のゲストメッセージバッファーを保持します。 これらのバッファーは、あるパーティションから別のパーティションに明示的に送信されたメッセージに対して、ゲストによって使用されます。 ポートが作成されると、ハイパーバイザーはポート所有者のメモリプールから 16 (16) メッセージバッファーを割り当てます。 これらのメッセージバッファーは、ポートが削除されると、メモリプールに返されます。

#### <a name="message-buffer-queues"></a>メッセージバッファーキュー

ハイパーバイザーでは、パーティション内の各パーティションと各仮想プロセッサについて、仮想プロセッサの SynIC の SINTx (合成割り込みソース) ごとに1つのメッセージバッファーのキューを保持します。 仮想プロセッサのすべてのメッセージキューは、仮想プロセッサの作成時またはリセット時に空になります。

#### <a name="reliability-and-sequencing-of-guest-message-buffers"></a>ゲストメッセージバッファーの信頼性とシーケンス処理

ゲストによって正常に送信されたメッセージは、ハイパーバイザーによる配信のためにキューに入れられました。 ターゲットパーティションによる実際の配信と受信は、適切な操作に依存します。 パーティションでは、その SynIC を無効にするか、SIMP を無効にすることによって、特定の仮想プロセッサへのメッセージ配信を無効にすることができます。

接続の中断は、配信されていない (キューに置かれた) メッセージには影響しません。 ターゲットポートを削除すると、そのポートのメッセージバッファーが使用可能かどうか、または配信されていない (キューに置かれた) メッセージが格納されているかどうかにかかわらず、常に解放

メッセージは、正常に送信された順序で到着します。 受信ポートが特定の仮想プロセッサに関連付けられている場合、メッセージは、ポストされた順序と同じ順序で到着します。 受信ポートが HV_ANY_VP に関連付けられている場合、メッセージは特定の順序で受信されるとは限りません。

## <a name="synic-event-flags"></a>SynIC イベントフラグ

SynIC では、メッセージに加えて、イベントフラグと呼ばれる2番目の種類のクロスパーティション通知メカニズムがサポートされています。 イベントフラグは、 [Hvcallsignalevent](hypercalls/HvCallSignalEvent.md) ハイパーコールを使用して明示的に設定することも、ハイパーバイザーによって暗黙的に設定することもできます。

### <a name="event-flags-versus-messages"></a>イベントフラグとメッセージ

イベントフラグは、メッセージよりも軽量であるため、オーバーヘッドが低くなります。 さらに、イベントフラグでは、ハイパーバイザー内でのバッファーの割り当てやキューは必要ありません。そのため、リソースが不足しているため、HvCallSignalEvent は失敗しません。

### <a name="event-flag-delivery"></a>イベントフラグの配信

パーティションは HvCallSignalEvent を呼び出すときに、イベントフラグ番号を指定します。 ハイパーバイザーは、受信側の仮想プロセッサの [Sief ページ](#sief-page)内でビットをアトミックに設定することによって応答します。 SynIC または SIEF ページが無効になっている仮想プロセッサは、潜在的なターゲットとは見なされません。 使用できるターゲットがない場合、ハイパーバイザーは操作を終了し、エラーを呼び出し元に返します。

イベントフラグが以前にクリアされた場合、ハイパーバイザーは、エッジによってトリガーされる割り込みを生成することによってフラグが設定されていることを、受信パーティションに通知しようとします。 ターゲットの仮想プロセッサとターゲットの SINTx は、ポートの作成の一部として指定されます。 SINTx がマスクされている場合、HvSignalEvent は HV_STATUS_INVALID_SYNIC_STATE を返します。

固定優先度の外部割り込みと同様、割り込みは仮想プロセッサによって確認されません。これは、プロセス優先順位レジスタ (PPR) が SINTx レジスタで指定されたベクターより小さく、割り込みが仮想プロセッサによってマスクされない (rFLAGS [IF] が1に設定されている) までです。

#### <a name="sief-page"></a>SIEF ページ

SIEF ページは、256バイトのイベントフラグの16要素配列で構成されています ( [HV_SYNIC_EVENT_FLAGS](datatypes/HV_SYNIC_EVENT_FLAGS.md)を参照してください)。 各配列要素は、単一の合成割り込みソース (SINTx) に対応します。

Sief ページのアドレスは、 [sief レジスタ](#siefp-register)に指定されています。 SIEF ページのアドレスは、各仮想プロセッサに対して一意である必要があります。 これらのページをプログラミングして、SIEF または SIM ページの他のインスタンスや、その他のオーバーレイページ (たとえば、ハイパーコールページ) と重複すると、未定義の動作が発生します。

仮想プロセッサによる SIEF ページへの読み取りおよび書き込みアクセスは、RAM への読み取りおよび書き込みアクセスと同様に動作します。 ただし、ハイパーバイザーの SynIC 実装では、特定のイベントに応答してページにも書き込まれます。

仮想プロセッサの作成とリセット時に、SIEF ページは0にクリアされます。

### <a name="recommended-event-flag-handling"></a>推奨されるイベントフラグの処理

ターゲットパーティション内のイベントフラグ interrupt service ルーチン (ISR) では、次の手順を実行することをお勧めします。

- イベントフラグを確認し、設定されているイベントフラグを確認します。
- LOCK や LOCK CMPXCHG などのロックされた (アトミック) 操作を使用して、1つ以上のイベントフラグをクリアします。
- APIC の EOI レジスタに書き込むことによって、ベクターの割り込みの終了を示します。
- 設定されたイベントフラグによって暗黙的に処理されるアクションを実行します。

## <a name="ports-and-connections"></a>ポートと接続

あるゲストから別のゲストに送信されるメッセージまたはイベントは、事前に割り当てられた接続を介して送信される必要があります。 接続は、宛先ポートに関連付けられている必要があります。

ポートは、受信側のメモリプールから割り当てられ、ターゲットの仮想プロセッサと SINTx を指定します。 イベントポートには、"ベースフラグ番号" と "フラグカウント" があり、呼び出し元はそのポートの有効なイベントフラグの範囲を指定できます。

接続は、送信側のメモリプールから割り当てられます。 接続が作成されるときは、有効なポートに関連付けられている必要があります。 このバインディングは、単純な一方向の通信チャネルを作成します。 その後、ポートが削除されても、その接続は失われます。

## <a name="synic-msrs"></a>SynIC MSRs

ローカル APIC に対して定義されているメモリマップトレジスタに加えて、次のモデル固有レジスタ (MSRs) が SynIC で定義されています。 各仮想プロセッサには、これらのレジスタの独自のコピーがあるため、個別にプログラミングできます。

| MSR アドレス             | レジスタ名         | 機能                             |
|-------------------------|-----------------------|--------------------------------------|
| 0x40000080              | SCONTROL              | SynIC コントロール                        |
| 0x40000081              | HIS              | SynIC のバージョン                        |
| 0x40000082              | SIEFP                 | [割り込みイベントフラグ] ページ           |
| 0x40000083              | SIMP                  | [割り込みメッセージ] ページ               |
| 0x40000084              | EOM                   | メッセージの終わり                       |
| 0x40000090              | SINT0                 | 割り込みソース 0 (ハイパーバイザー)      |
| 0x40000090              | SINT1                 | 割り込みソース1                   |
| 0x40000090              | SINT2                 | 割り込みソース2                   |
| 0x40000090              | SINT3                 | 割り込みソース3                   |
| 0x40000090              | SINT4                 | 割り込みソース4                   |
| 0x40000090              | SINT5                 | 割り込みソース5                   |
| 0x40000090              | SINT6                 | 割り込みソース6                   |
| 0x40000090              | SINT7                 | 割り込みソース7                   |
| 0x40000090              | SINT8                 | 割り込みソース8                   |
| 0x40000090              | SINT9                 | 割り込みソース9                   |
| 0x40000090              | SINT10                | 割り込みソース10                  |
| 0x40000090              | SINT11                | 割り込みソース11                  |
| 0x40000090              | SINT12                | 割り込みソース12                  |
| 0x40000090              | SINT13                | 割り込みソース13                  |
| 0x40000090              | SINT14                | 割り込みソース14                  |
| 0x40000090              | SINT15                | 割り込みソース15                  |

### <a name="scontrol-register"></a>SCONTROL レジスタ

このレジスタは、仮想プロセッサの SynIC の動作を制御するために使用されます。

仮想プロセッサの作成時およびプロセッサのリセット時に、この SCONTROL (SynIC コントロールレジスタ) の値は0x0000000000000000 になります。 このため、メッセージキューとイベントフラグの通知は無効になります。

| Bits      | フィールド           | 説明                                                                 | 属性     |
|-----------|-----------------|-----------------------------------------------------------------------------|----------------|
| 63:1      | RsvdP           | 値を保持する必要があります                                                     | 読み取り/書き込み   |
| 0         | 有効化          | この仮想プロセッサを設定すると、メッセージキューとイベントフラグの通知を SynIC に投稿できるようになります。 オフにすると、メッセージキューとイベントフラグの通知をこの仮想プロセッサに送信できなくなります。 | 読み取り/書き込み |

### <a name="sversion-register"></a>SVERSION レジスタ

これは読み取り専用レジスタであり、SynIC のバージョン番号を返します。 このレジスタへの書き込みを試みると、#GP エラーが発生します。

| Bits      | フィールド           | 説明                                                                 | 属性     |
|-----------|-----------------|-----------------------------------------------------------------------------|----------------|
| 63:32     | RsvdP           |                                                                             | Read           |
| 31:0      | SynIC のバージョン   | SynIc のバージョン番号                                                 | Read           |

#### <a name="siefp-register"></a>SIEFP レジスタ

仮想プロセッサの作成時およびプロセッサのリセット時に、この SIEFP (合成割り込みイベントフラグページ) レジスタの値は0x0000000000000000 になります。 したがって、SIEFP は既定で無効になっています。 ゲストは、ビット0を設定して有効にする必要があります。 指定されたベースアドレスがパーティションの GPA 領域の末尾を超えている場合、SIEFP ページはゲストにアクセスできません。 登録を変更するとき、ゲストは予約済みのビットの値 (1 ~ 11) を保持して、将来の互換性を維持する必要があります。

| Bits      | フィールド           | 説明                                                                 | 属性     |
|-----------|-----------------|-----------------------------------------------------------------------------|----------------|
| 63:12     | ベース アドレス    | SIEFP のベースアドレス (GPA space 内) (無効と見なされる下位12ビット)   | 読み取り/書き込み   |
| 11:1      | RsvdP           | 予約済み、値を保持する必要があります                                         | 読み取り/書き込み   |
| 0         | 有効化          | SIEFP の有効化                                                                | 読み取り/書き込み   |

#### <a name="simp-register"></a>SIMP レジスタ

仮想プロセッサの作成時およびプロセッサのリセット時に、この SIMP (合成割り込みメッセージページ) レジスタの値は0x0000000000000000 になります。 このため、SIMP は既定で無効になっています。 ゲストは、ビット0を設定して有効にする必要があります。 指定されたベースアドレスがパーティションの GPA 領域の末尾を超えている場合、SIMP ページはゲストにアクセスできません。 登録を変更するとき、ゲストは予約済みのビットの値 (1 ~ 11) を保持して、将来の互換性を維持する必要があります。

| Bits      | フィールド           | 説明                                                                 | 属性     |
|-----------|-----------------|-----------------------------------------------------------------------------|----------------|
| 63:12     | ベース アドレス    | SIMP のベースアドレス (GPA space 内) (無効になっていると想定されている下位12ビット)   | 読み取り/書き込み   |
| 11:1      | RsvdP           | 予約済み、値を保持する必要があります                                         | 読み取り/書き込み   |
| 0         | 有効化          | SIMP の有効化                                                                 | 読み取り/書き込み   |

#### <a name="sintx-registers"></a>SINTx レジスタ

仮想プロセッサの作成時に、すべての SINTx (合成割り込みソース) レジスタの既定値は0x0000000000010000 です。 したがって、すべての合成割り込みソースが既定でマスクされます。 ゲストは、適切なベクターをプログラミングし、ビット16をクリアすることで、これらのマスクを解除する必要があります。

ポーリングビットの設定は、実際の割り込みが生成されない点を除いて、割り込みソースのマスク解除に影響します。

AutoEOI フラグは、割り込みが仮想プロセッサに配信されるときに、ハイパーバイザーによって暗黙的な EOI が実行されることを示します。 さらに、ハイパーバイザーは、仮想 APIC の "サービス内登録" (ISR) の対応するフラグを自動的にクリアします。 ゲストがこの動作を有効にした場合、その割り込みサービスルーチンで EOI を実行することはできません。
AutoEOI フラグはいつでも有効にすることができますが、ゲストは、フライト中の割り込みに対して明示的な EOI を実行する必要があります。タイミングの考慮事項により、特定の割り込みに EOI が必要かどうかを知ることが難しくなります 同様に、常に AutoEOI フラグをオフにすることもできますが、実行中の割り込みに関する同じ懸念事項が適用されます。

Vector の有効な値は16-255 を含みます。 無効なベクター番号を指定すると、#GP になります。

| Bits      | フィールド           | 説明                                                                 | 属性     |
|-----------|-----------------|-----------------------------------------------------------------------------|----------------|
| 63:19     | RsvdP           | 予約済み、値を保持する必要があります                                         | 読み取り/書き込み   |
| 18        | ポーリング         | ポーリングモードを有効にする                                                        | 読み取り/書き込み   |
| 17        | AutoEOI         | 割り込み配信時に暗黙的な EOI を実行するかどうかを設定します          | 読み取り/書き込み   |
| 16        | [マスク]          | シントをマスクするかどうかを設定します                                                   | 読み取り/書き込み   |
| 15:8      | RsvdP           | 予約済み、値を保持する必要があります                                         | 読み取り/書き込み   |
| 7:0       | ベクター          | 割り込みベクター                                                            | 読み取り/書き込み   |

#### <a name="eom-register"></a>EOM レジスタ

ゲストによってメッセージの終わり (EOM) の登録に書き込むと、ハイパーバイザーは仮想プロセッサに関連付けられている内部メッセージバッファーキューをスキャンします。 メッセージバッファーキューにキューに置かれたメッセージバッファーが含まれている場合、ハイパーバイザーはメッセージの配信を試みます。 SIM ページが有効になっていて、SINTx に対応するメッセージスロットが空の場合 (つまり、ヘッダーのメッセージの種類が HvMessageTypeNone に設定されている場合)、メッセージ配信は成功します。 メッセージが正常に配信されると、対応する内部メッセージバッファーがデキューされ、free とマークされます。 対応する SINTx がマスクされていない場合は、エッジによってトリガーされる割り込みが配信されます (つまり、IRR 内の対応するビットが設定されます)。

このレジスタは、ゲストがメッセージを "ポーリング" するために使用できます。 また、無効になっている (つまりマスクされている) SINTx のメッセージキューをドレインする手段としても使用できます。

メッセージキューがすべて空の場合、EOM register への書き込みは非操作です。

EOM register からの読み取りは常に0を返します。

| Bits      | フィールド           | 説明                                                                 | 属性     |
|-----------|-----------------|-----------------------------------------------------------------------------|----------------|
| 63:0      | RsvdZ           | 書き込み専用トリガー                                                          | Write          |