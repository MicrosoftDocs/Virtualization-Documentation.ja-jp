---
title: 仮想 MMU
description: ハイパーバイザー仮想 MMU インターフェイス
keywords: hyper-v
author: alexgrest
ms.author: alegre
ms.date: 10/15/2020
ms.topic: reference
ms.prod: windows-10-hyperv
ms.openlocfilehash: 7bfb7ba5426df0192bf142a2fc4e492da2fa21ef
ms.sourcegitcommit: d43632e3dc22e2b7a256b5c15fbb665c047de286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/16/2020
ms.locfileid: "92120762"
---
# <a name="virtual-mmu"></a>仮想 MMU

各パーティションによって公開される仮想マシンインターフェイスには、メモリ管理装置 (MMU) が含まれます。 ハイパーバイザーパーティションによって公開される仮想 MMU は、通常、既存の MMUs と互換性があります。

## <a name="virtual-mmu-overview"></a>Virtual MMU の概要

仮想プロセッサは仮想メモリと仮想 TLB (変換のルックアサイドバッファー) を公開します。これにより、仮想アドレスから (ゲスト) 物理アドレスへの変換がキャッシュされます。 論理プロセッサ上の TLB と同様、仮想 TLB は整合性のないキャッシュであり、このような非一貫性はゲストに表示されます。 ハイパーバイザーは、TLB をフラッシュする操作を公開します。 ゲストはこれらの操作を使用して、不整合な可能性のあるエントリを削除し、仮想アドレスの翻訳を予測可能にします。

### <a name="compatibility"></a>互換性

ハイパーバイザーによって公開される仮想 MMU は、一般に x64 プロセッサ内の物理 MMU と互換性があります。 次のようなゲストに見える相違点が存在します。

- CR3。PWT と CR3。一部のハイパーバイザー実装では、PCD ビットがサポートされていない可能性があります。 このような実装では、ゲストは、MOV から CR3 命令またはタスクゲートスイッチによってこれらのフラグを設定しようとしましたが、無視されます。 HvSetVpRegisters または HvSwitchVirtualAddressSpace を使用してプログラムによってこれらの bits を設定しようとすると、エラーが発生する可能性があります。
- リーフページのテーブルエントリ内の PWT および PCD ビット (たとえば、4 K ページの PTE と大きいページの PWT) は、マップされるページのキャッシュを指定します。 非リーフページテーブルエントリ内の PAT、PWT、および PCD ビットは、階層内の次のページテーブルのキャッシュを示します。 ハイパーバイザー実装によっては、これらのフラグがサポートされない場合があります。 このような実装では、ハイパーバイザーによって実行されるすべてのページテーブルへのアクセスは、ライトバックキャッシュ属性を使用して行われます。 これは、ページテーブルエントリに書き込まれた、特にアクセスおよびダーティビットに影響します。 ゲストが、非リーフページテーブルエントリ内で PAT、PWT、または PCD ビットを設定した場合、そのページテーブルによってマップされているページに仮想プロセッサからアクセスすると、"サポートされていない機能" というメッセージが生成されることがあります。
- CR0 レジスタ。一部のハイパーバイザー実装では、CD (cache disable) ビットがサポートされていない可能性があります。 このような実装では、CR0 レジスタです。CD ビットを0に設定する必要があります。 ゲストが MOV から CR0 レジスタ命令にこのフラグを設定しようとしても、無視されます。 HvSetVpRegisters を使用してプログラムでこのビットを設定しようとすると、エラーが発生します。
- PAT (ページアドレスの種類) MSR は、VP ごとの登録です。 ただし、パーティション内のすべての仮想プロセッサが PAT MSR を同じ値に設定すると、新しい効果がパーティション全体の効果になります。
- セキュリティと分離の理由により、INVD 命令は、WBINVD 命令のように機能するように仮想化され、いくつかの違いがあります。 セキュリティ上の理由から、代わりに CLFLUSH を使用する必要があります。

### <a name="legacy-tlb-management-operations"></a>レガシ TLB 管理操作

X64 アーキテクチャには、プロセッサの TLBs を管理するためのいくつかの方法が用意されています。 ハイパーバイザーによって仮想化されるメカニズムは次のとおりです。

- INVLPG 命令は、プロセッサの TLB からの1ページの翻訳を無効にします。 指定した仮想アドレスがもともと 4 K ページとしてマップされている場合、このページの変換は TLB から削除されます。 指定された仮想アドレスがもともと "large page" (MMU モードによっては 2 MB または 4 MB) としてマップされている場合は、大きなページ全体の変換が TLB から削除されます。 INVLPG 命令は、グローバル翻訳と非グローバル翻訳の両方をフラッシュします。 グローバル翻訳は、ページテーブルエントリ内に "global" ビットが設定されているものとして定義されます。
- CR3 を変更する .MOV to CR3 命令およびタスクスイッチは、プロセッサの TLB 内のすべての非グローバルページの翻訳を無効にします。
- CR4 を変更する MOV から CR4 命令。CR4 の PGE (グローバルページ有効) ビット。PSE (ページサイズの拡張) ビットまたは CR4。PAE (ページアドレス拡張) ビットは、プロセッサの TLB 内のすべての翻訳 (グローバルおよび非グローバル) を無効にします。

これらの無効化操作はすべて1つのプロセッサにのみ影響することに注意してください。 他のプロセッサでの翻訳を無効にするには、ソフトウェアでソフトウェアベースの "TLB のシュートダウン" メカニズムを使用する必要があります (通常、プロセス間の割り込みを使用して実装されます)。

### <a name="virtual-tlb-enhancements"></a>仮想 TLB の機能強化

前に説明した従来の TLB 管理メカニズムのサポートに加えて、ハイパーバイザーは、ゲストが仮想 TLB をより効率的に管理できるようにする拡張機能のセットもサポートしています。 これらの拡張操作は、従来の TLB 管理操作と同じ意味で使用できます。

ハイパーバイザーは、次のハイパーバイザーをサポートして TLBs を無効にします。

| ハイパーコール                                                                           | 説明                                     |
|-------------------------------------------------------------------------------------|-------------------------------------------------|
| [HvCallFlushVirtualAddressSpace](hypercalls/HvCallFlushVirtualAddressSpace.md)      | 指定されたアドレス空間に属するすべての仮想 TLB エントリを無効にします。    |
| [Hvcallflushvirtualaddressspace Ex](hypercalls/HvCallFlushVirtualAddressSpaceEx.md)  | HvCallFlushVirtualAddressSpace と同様に、はスパース VP を入力として受け取ります。    |
| [HvCallFlushVirtualAddressList](hypercalls/HvCallFlushVirtualAddressList.md)        | 指定されたアドレス空間の一部を無効にします。    |
| [HvCallFlushVirtualAddressListEx](hypercalls/HvCallFlushVirtualAddressListEx.md)    | HvCallFlushVirtualAddressList と同様に、はスパース VP を入力として受け取ります。    |

一部のシステム (ハードウェアで仮想化が十分にサポートされている) では、ローカルまたはリモート (クロスプロセッサ) の TLB 無効化で、従来の TLB 管理手順がより高速になることがあります。 最適なパフォーマンスを求めているゲストは、CPUID リーフ0x40000004 を使用して、ハイパーコールを使用して実装する動作を決定する必要があります。

- UsehypercallforaddressHvCallSwitchAddressSpace: このフラグが設定されている場合、呼び出し元は、アドレス空間を切り替えるためにを使用する方が高速であると想定する必要があります。 このフラグがオフの場合は、MOV から CR3 への命令が推奨されます。
- UseHypercallForLocalFlush: このフラグが設定されている場合、呼び出し元は、(INVLPG または MOV ではなく) ハイパースレッディングを使用して仮想 TLB から1つ以上のページをフラッシュする方が高速であると想定する必要があります。
- Usehypercallforremoteflusの Localflush全体: このフラグが設定されている場合、呼び出し元は、(ゲストによって生成されたプロセッサ間の割り込みを使用するのではなく) ハイパースレッディングを使用する方が高速であることを前提として、仮想 TLB から1つ以上のページをフラッシュします。

## <a name="memory-cache-control-overview"></a>メモリキャッシュ制御の概要

ハイパーバイザーは、ゲストの GVA 領域内でマップされたページのゲスト定義のキャッシュ設定をサポートしています。 使用可能なキャッシュ設定とその意味の詳細については、Intel または AMD のドキュメントを参照してください。

仮想プロセッサが GVA 領域を介してページにアクセスすると、ハイパーバイザーは、ページをマップするために使用されるゲストページテーブルエントリ内のキャッシュ属性ビット (PAT、PWT、および PCD) を受け入れます。 この3つのビットは、パーティションの PAT (ページアドレスの種類) レジスタのインデックスとして使用され、ページの最終的なキャッシュ設定を参照します。

GPA space を介して直接アクセスされたページ (たとえば、CR0 レジスタのためにページングが無効になっている場合など)。PG がクリアされました) MTRRs で定義されているキャッシュを使用します。 ハイパーバイザー実装が virtual MTRRs をサポートしていない場合は、WB のキャッシュが想定されます。

### <a name="mixing-cache-types-between-a-partition-and-the-hypervisor"></a>パーティションとハイパーバイザー間でのキャッシュの種類の混在

ゲストは、GPA 領域内の一部のページがハイパーバイザーによってアクセスされる可能性があることに注意する必要があります。 次の一覧は、完全ではありませんが、いくつかの例を示しています。

- ハイパーコールの入力パラメーターまたは出力パラメーターを含むページ
- ハイパーコールページ、SynIC SIEF および SIM ページ、および stats ページを含むすべてのオーバーレイページ

ハイパーバイザーは、常に WB のキャッシュ設定を使用して、ハイパーコールパラメーターとオーバーレイページへのアクセスを実行します。