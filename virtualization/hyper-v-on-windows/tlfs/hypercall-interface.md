---
title: ハイパーコールインターフェイス
description: ハイパーバイザーハイパーコールインターフェイス
keywords: hyper-v
author: alexgrest
ms.author: alegre
ms.date: 10/15/2020
ms.topic: reference
ms.prod: windows-10-hyperv
ms.openlocfilehash: 88014624350a13b9f2672b3a08ac4161463fa602
ms.sourcegitcommit: d43632e3dc22e2b7a256b5c15fbb665c047de286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/16/2020
ms.locfileid: "92120837"
---
# <a name="hypercall-interface"></a>ハイパーコールインターフェイス

ハイパーバイザーは、ゲストの呼び出しメカニズムを提供します。 このような呼び出しはハイパーコールと呼ばれます。 各ハイパーコールは、入力パラメーターと出力パラメーターのセットを定義します。 これらのパラメーターは、メモリベースのデータ構造の観点で指定されます。 入力データ構造と出力データ構造体のすべての要素は、最大8バイトまでの自然な境界に埋め込まれます (つまり、2バイトの要素は2バイトの境界上にある必要があります)。

2つ目のハイパーコール呼び出し規則は、オプションとして、2つ以下の入力パラメーターを持ち、出力パラメーターを持たないハイパーコールのサブセットに対して使用することもできます。 この呼び出し規約を使用する場合、入力パラメーターは汎用レジスタで渡されます。

3番目のハイパーコール呼び出し規約は、必要に応じて、入力パラメーターブロックが112バイトまでのハイパーコールのサブセットに対して使用できます。 この呼び出し規約を使用する場合、入力パラメーターは、volatile XMM レジスタを含むレジスタに渡されます。

入力と出力のデータ構造は、両方とも8バイトの境界のメモリに配置され、サイズが8バイトの倍数に埋め込まれている必要があります。 埋め込み領域内の値は、ハイパーバイザーによって無視されます。

出力の場合、ハイパーバイザーは、埋め込み領域を上書きすることができます (ただし、これは保証されません)。 埋め込み領域を上書きする場合は、ゼロを書き込みます。

## <a name="hypercall-classes"></a>ハイパーコールクラス

ハイパーコールには、simple と rep の2つのクラスがあります ("繰り返し" の短い)。 単純なハイパーコールは、1つの操作を実行し、入力パラメーターと出力パラメーターの固定サイズセットを持っています。 Rep ハイパーコールは、一連の単純なハイパーコールと同様に機能します。 入力パラメーターと出力パラメーターの固定サイズセットに加えて、rep ハイパーコールハイパーコールには、固定サイズの入力要素または出力要素のリストが含まれます。

呼び出し元が最初に rep ハイパーコールを呼び出したときに、入力パラメーターリストまたは出力パラメーターリスト内の要素の数を示す rep カウントを指定します。 また、呼び出し元は、使用する必要がある次の入力または出力要素を示す rep start インデックスも指定します。 ハイパーバイザーは、リストの順序で (つまり、要素のインデックスを増やすことによって) 担当のパラメーターを処理します。

後続の rep ハイパーコールの呼び出しでは、rep start インデックスは、完了した要素の数と、rep count の値 (残りの要素の数) を示します。 たとえば、呼び出し元が指定した担当者の数が25で、時間制約内で20回のイテレーションだけが完了した場合、ハイパーコールは、担当者の開始インデックスを20に更新した後、呼び出し元の仮想プロセッサに制御を戻します。 ハイパーコールが再実行されると、ハイパーバイザーは要素20で再開し、残りの5つの要素を完了します。

要素の処理中にエラーが発生した場合は、エラーが発生する前に正常に処理された要素の数を示す、担当者が完了した数と共に適切な状態コードが提供されます。 指定されたハイパーコール制御ワードが有効であることを前提として (次を参照)、入力/出力パラメーターの一覧にアクセスできますが、ハイパーバイザーでは少なくとも1つの担当者を試行することが保証されていますが、呼び出し元に制御を戻す前にリスト全体を処理する必要はありません。

## <a name="hypercall-continuation"></a>ハイパーコール継続

ハイパーコールは、多くのサイクルを必要とする複雑な命令と考えることができます。 ハイパーバイザーは、ハイパーコールを呼び出した仮想プロセッサに制御を返す前に、ハイパーコールの実行を50μs 以下に制限しようとします。 ハイパーコール操作によっては、50μs 保証の作成が困難になることが非常に複雑になります。 したがって、ハイパーバイザーは、すべての rep ハイパーコールフォームを含む、一部のハイパーコールのハイパーコール継続メカニズムに依存します。

ハイパーコール継続機構は、ほとんどの場合、呼び出し元に対して透過的です。 ハイパーコールが指定された制限時間内に完了できない場合は、制御が呼び出し元に返されますが、命令ポインターは、ハイパーコールを呼び出した命令を越えることはありません。 これにより、保留中の割り込みを処理し、他の仮想プロセッサをスケジュールすることができます。 元の呼び出しスレッドが実行を再開すると、ハイパーコール命令が再実行され、操作の完了に向けて進行状況が進みます。

ほとんどの単純なハイパーコールは、指定された制限時間内に完了することが保証されます。 ただし、少数の単純なハイパーコールでは、より多くの時間が必要になる場合があります。 これらのハイパーコールは、ハイパーコールの継続を、rep のハイパーコールと同様の方法で使用します。 このような場合、操作には2つ以上の内部状態が含まれます。 最初の呼び出しでは、オブジェクト (パーティションまたは仮想プロセッサなど) を1つの状態に配置し、繰り返し呼び出した後、状態は最後にターミナル状態に遷移します。 このパターンに従う各ハイパーコールについて、中間内部状態の可視副作用が説明されています。

## <a name="hypercall-atomicity-and-ordering"></a>ハイパーコールの原子性と順序付け

特に明記されている場合を除き、ハイパーコールによって実行されるアクションは、他のすべてのゲスト操作 (たとえば、ゲスト内で実行される命令) と、システムで実行されている他のすべてのハイパーコールの両方に対してアトミックです。 単純なハイパーコールは、1つのアトミックなアクションを実行します。rep ハイパーコールは、複数の独立したアトミックアクションを実行します。

ハイパーコール継続を使用する単純なハイパーコールには、外部から参照できる複数の内部状態が関係している場合があります。 このような呼び出しは、複数のアトミック操作を構成します。

各ハイパーコールアクションは、入力パラメーターの読み取りや結果の書き込みを行うことができます。 各アクションへの入力は、ハイパーコールが作成されてからアクションが実行されるまで、任意の粒度で、いつでも読み取ることができます。 各アクションに関連付けられた結果 (出力パラメーター) は、アクションが実行されてからハイパーコールが戻る前に、任意の粒度で記述できます。

ゲストは、実行中のハイパーコールに関連する入力パラメーターまたは出力パラメーターの検査や操作を避ける必要があります。 ハイパーコールを実行している仮想プロセッサはこの操作を行うことができません (ゲストの実行はハイパーコールが返されるまで中断されます) が、他の仮想プロセッサがそれを実行できないようにすることはできません。 このように動作するゲストは、クラッシュしたり、パーティション内で破損したりする可能性があります。

## <a name="legal-hypercall-environments"></a>法的ハイパーコール環境

ハイパーコールは、最も特権の高いゲストプロセッサモードからのみ呼び出すことができます。 X64 platfoms では、これは、現在の特権レベル (CPL) が0の保護モードを意味します。 実際のモードのコードは、有効な CPL 0 で実行されますが、リアルモードではハイパーコールは許可されません。 無効なプロセッサモードでハイパーコールを呼び出そうとすると、#UD (未定義の操作) 例外が生成されます。

すべてのハイパーコールは、アーキテクチャによって定義されたハイパーコールインターフェイス (下記参照) を介して呼び出す必要があります。 他の方法でハイパーコールを呼び出そうとした場合 (たとえば、ハイパーコールコードページから別の場所にコードをコピーしてそこから実行する場合)、未定義の操作 (#UD) 例外が発生する可能性があります。 ハイパーバイザーでは、この例外が確実に配信されるとは限りません。

## <a name="alignment-requirements"></a>アラインメントの要件

呼び出し元は、入力パラメーターまたは出力パラメーターの64ビットのゲスト物理アドレス (GPA) を指定する必要があります。 GPA ポインターは8バイトでアラインする必要があります。 ハイパーコールが入力パラメーターまたは出力パラメーターを含まない場合、ハイパーバイザーは対応する GPA ポインターを無視します。

入力パラメーターと出力パラメーターの一覧は、重複したりページ境界を越えることはできません。 ハイパーコールの入力ページと出力ページは、"オーバーレイ" ページではなく、GPA ページである必要があります。 仮想プロセッサが入力パラメーターをオーバーレイページに書き込み、このページ内で GPA を指定すると、入力パラメーターリストへのハイパーバイザーアクセスは未定義になります。

ハイパーバイザーは、要求されたハイパーコールを実行する前に、呼び出し元のパーティションが入力ページから読み取ることができることを検証します。 この検証は、指定された GPA がマップされ、GPA が読み取り可能とマークされている2つのチェックで構成されます。 これらのテストのいずれかが失敗した場合、ハイパーバイザーはメモリインターセプトメッセージを生成します。 出力パラメーターを持つハイパーコールでは、ハイパーバイザーによって、パーティションが出力ページに書き込めるかどうかが検証されます。 この検証は、指定された GPA がマップされ、GPA が書き込み可能としてマークされている2つのチェックで構成されます。

## <a name="hypercall-inputs"></a>ハイパーコールの入力

呼び出し元は、ハイパーコール入力値と呼ばれる64ビット値でハイパーコールを指定します。 これは次のような形式になります。

| フィールド                   | Bits    | 情報提供済み                                        |
|-------------------------|---------|-------------------------------------------------------------|
| 呼び出しコード               | 15-0    | 要求されるハイパーコールを指定します                      |
| 速い                    | 16      | ハイパーコールがレジスタベースの呼び出し規則を使用するかどうかを指定します 0 = メモリベース、1 = レジスタベース |
| 変数ヘッダーサイズ    | 26-17   | 変数ヘッダーのサイズ (QWORDS)。                   |
| RsvdZ                   | 31-27   | 0にする必要があります                                                |
| 担当者数               | 43-32   | 担当者の合計数 (rep 呼び出しの場合は、それ以外の場合は0にする必要があります) |
| RsvdZ                   | 47-44   | 0にする必要があります                                                |
| 担当者の開始インデックス         | 59-48   | 開始インデックス (rep 呼び出しの場合は、それ以外の場合は0にする必要があります)       |
| RsvdZ                   | 64-60   | 0にする必要があります                                                |

Rep ハイパーコールの場合、[rep count] フィールドは、担当者の合計数を示します。 Rep start インデックスは、リストの先頭を基準とした特定の繰り返しを示します (ゼロはリスト内の最初の要素が処理されることを示します)。 そのため、rep count の値は、常に rep 開始インデックスよりも大きくする必要があります。

高速フラグが0の場合にハイパーコール入力のマッピングを登録します。

| X64     | x86     | 情報提供済み                                        |
|---------|---------|-------------------------------------------------------------|
| RCX     | EDX: EAX | ハイパーコールの入力値                                       |
| RDX     | EBX: ECX | 入力パラメーター GPA                                        |
| R8      | EDI: ESI | 出力パラメーター GPA                                       |

ハイパーコールの入力値は、入力パラメーターと出力パラメーターを指す GPA と共にレジスタに渡されます。

X64 では、レジスタマッピングは、呼び出し元が32ビット (x86) モードと64ビット (x64) モードのどちらで実行されているかによって異なります。 ハイパーバイザーは、EFER の値に基づいて、呼び出し元のモードを決定します。LMA と .CS。 両方のフラグが設定されている場合、呼び出し元は64ビットの呼び出し元であると見なされます。

高速フラグが1の場合にハイパーコール入力のマッピングを登録します。

| X64     | x86     | 情報提供済み                                        |
|---------|---------|-------------------------------------------------------------|
| RCX     | EDX: EAX | ハイパーコールの入力値                                       |
| RDX     | EBX: ECX | 入力パラメーター                                             |
| R8      | EDI: ESI | [出力パラメーター]                                            |

ハイパーコールの入力値は、入力パラメーターと共にレジスタに渡されます。

### <a name="variable-sized-hypercall-input-headers"></a>可変サイズのハイパーコール入力ヘッダー

ほとんどのハイパーコール入力ヘッダーのサイズは固定されています。 そのため、ゲストからハイパーバイザーに渡されるヘッダーデータの量は、ハイパーコールコードによって暗黙的に指定されるため、個別に指定する必要はありません。 ただし、一部のハイパーコールでは、大量のヘッダーデータが必要です。 通常、このようなハイパーコールは、固定サイズの入力ヘッダーと、可変サイズの追加のヘッダー入力を持ちます。

可変サイズのヘッダーは、固定されたハイパーコール入力 (8 バイトにアラインメントされ、サイズが8バイトの倍数) に似ています。 呼び出し元は、入力ヘッダーとして提供しているデータの量を指定する必要があります。 このサイズは、ハイパーコール入力値の一部として提供されます (上記の表の「変数ヘッダーサイズ」を参照してください)。

固定ヘッダーサイズは、ヘッダーの合計サイズを指定するのではなく、暗黙的に行われるため、入力コントロールでは変数部分のみが提供されます。

```
Variable Header Bytes = {Total Header Bytes - sizeof(Fixed Header)} rounded up to nearest multiple of 8

Variable HeaderSize = Variable Header Bytes / 8
```

可変サイズの入力ヘッダーを受け入れるように明示的に記述されていないハイパーコールに対して、0以外の変数ヘッダーサイズを指定することはできません。 このような場合、ハイパーコールはのリターンコードになり `HV_STATUS_INVALID_HYPERCALL_INPUT` ます。

可変サイズの入力ヘッダーを受け入れるハイパーコールの呼び出しでは、すべてのヘッダー入力が固定サイズのヘッダー内に完全に適合している可能性があります。 このような場合、可変サイズの入力ヘッダーはゼロサイズで、ハイパーコール入力の対応するビットは0に設定する必要があります。

それ以外にも、呼び出し規約に関しては、可変サイズの入力ヘッダーを受け入れるハイパーコールは固定サイズの入力ヘッダーハイパーコールに似ています。 また、可変サイズのヘッダーハイパーコールが、rep セマンティクスをさらにサポートすることもできます。 このような場合、担当要素はヘッダーの後に通常の方法で配置されます。ただし、ヘッダーの合計サイズには、固定部分と可変部分の両方が含まれます。 他のすべてのルールは同じままです。たとえば、最初の rep 要素は8バイトでアラインする必要があります。

### <a name="xmm-fast-hypercall-input"></a>XMM Fast ハイパーコールの入力

X64 プラットフォームでは、ハイパーバイザーは XMM fast ハイパーコールを使用します。これにより、一部のハイパーコールでは、3つ以上の入力パラメーターが必要な場合でも、高速ハイパーコールインターフェイスのパフォーマンスの向上を利用できます。 XMM fast ハイパーコールインターフェイスは6つの XMM レジスタを使用して、呼び出し元が入力パラメーターブロックを最大112バイトのサイズに渡すことを許可します。

XMM fast ハイパーコールインターフェイスの可用性は、「ハイパーバイザー機能 Id」 CPUID リーフ (0x40000003) で示されています。

- ビット 4: XMM レジスタを介してハイパーコール入力を渡すためのサポートを利用できます。

XMM fast 出力のサポートを示す別のフラグがあることに注意してください。 ハイパーバイザーが可用性を示していない場合にこのインターフェイスを使用しようとすると、#UD エラーになります。

#### <a name="register-mapping-input-only"></a>レジスタマッピング (入力のみ)

| X64     | x86     | 情報提供済み                                        |
|---------|---------|-------------------------------------------------------------|
| RCX     | EDX: EAX | ハイパーコールの入力値                                       |
| RDX     | EBX: ECX | 入力パラメーターブロック                                       |
| R8      | EDI: ESI | 入力パラメーターブロック                                       |
| XMM0    | XMM0    | 入力パラメーターブロック                                       |
| XMM1    | XMM1    | 入力パラメーターブロック                                       |
| XMM2    | XMM2    | 入力パラメーターブロック                                       |
| XMM3    | XMM3    | 入力パラメーターブロック                                       |
| XMM4    | XMM4    | 入力パラメーターブロック                                       |
| XMM5    | XMM5    | 入力パラメーターブロック                                       |

ハイパーコールの入力値は、入力パラメーターと共にレジスタに渡されます。 レジスタマッピングは、呼び出し元が32ビット (x86) モードと64ビット (x64) モードのどちらで実行されているかによって異なります。 ハイパーバイザーは、EFER の値に基づいて、呼び出し元のモードを決定します。LMA と .CS。 両方のフラグが設定されている場合、呼び出し元は64ビットの呼び出し元であると見なされます。 入力パラメーターブロックが112バイトよりも小さい場合、レジスタ内の余分なバイトは無視されます。

## <a name="hypercall-outputs"></a>ハイパーコールの出力

すべてのハイパーコールハイパーは、ハイパーコール result 値と呼ばれる64ビット値を返します。 これは次のような形式になります。

| フィールド           | Bits  | 解説                                                                               |
|-----------------|-------|---------------------------------------------------------------------------------------|
| 結果          | 15-0  | `HV_STATUS` 成功または失敗を示すコード                                        |
| Rsvd            | 31-16 | 呼び出し元は、これらのビットの値を無視する必要があります。                                         |
| 完了した担当者  | 43-32 | 成功した担当者の数                                                 |
| RsvdZ           | 63-40 | 呼び出し元は、これらのビットの値を無視する必要があります。                                         |

Rep ハイパーコールの場合、担当者の完了フィールドは、担当者の開始インデックスに対して相対的ではなく、担当者の合計数です。 たとえば、呼び出し元が指定した担当者の開始インデックスが5で、担当者の数が10である場合、"担当者の完了" フィールドは正常に完了したときに10を示します。

ハイパーコールの結果値はレジスタに戻されます。 レジスタマッピングは、呼び出し元が32ビット (x86) モードと64ビット (x64) モードのどちらで実行されているかによって異なります (上記参照)。 ハイパーコール出力のレジスタマッピングは次のとおりです。

| X64     | x86     | 情報提供済み                                        |
|---------|---------|-------------------------------------------------------------|
| RAX     | EDX: EAX | ハイパーコールの結果値                                      |

### <a name="xmm-fast-hypercall-output"></a>XMM Fast ハイパーコールの出力

ハイパーバイザーが XMM fast ハイパーコールの入力をサポートするのと同様に、同じレジスタを共有して出力を返すことができます。 これは、x64 プラットフォームでのみサポートされています。

XMM レジスタを使用して出力を返す機能は、"ハイパーバイザー機能識別" CPUID リーフ (0x40000003) で示されます。

- ビット 15: XMM レジスタ経由でハイパーコール出力を返すためのサポートを利用できます。

XMM fast 入力のサポートを示す別のフラグがあることに注意してください。 ハイパーバイザーが可用性を示していない場合にこのインターフェイスを使用しようとすると、#UD エラーになります。

#### <a name="register-mapping-input-and-output"></a>レジスタマッピング (入力と出力)

入力パラメーターを渡すために使用されていないレジスタは、出力を返すために使用できます。 言い換えると、入力パラメーターブロックが112バイト未満 (最も近い16バイトのアラインメントされたチャンクに切り上げられます) の場合、残りのレジスタはハイパーコール出力を返します。

| x64     | 情報提供済み                                        |
|---------|-------------------------------------------------------------|
| RDX     | 入力ブロックまたは出力ブロック                                       |
| R8      | 入力ブロックまたは出力ブロック                                       |
| XMM0    | 入力ブロックまたは出力ブロック                                       |
| XMM1    | 入力ブロックまたは出力ブロック                                       |
| XMM2    | 入力ブロックまたは出力ブロック                                       |
| XMM3    | 入力ブロックまたは出力ブロック                                       |
| XMM4    | 入力ブロックまたは出力ブロック                                       |
| XMM5    | 入力ブロックまたは出力ブロック                                       |

たとえば、入力パラメーターブロックのサイズが20バイトの場合、ハイパーバイザーは次の12バイトを無視します。 残りの80バイトにはハイパーコール出力 (該当する場合) が含まれます。

## <a name="volatile-registers"></a>揮発性レジスタ

ハイパーコールでは、次の条件で指定されたレジスタ値のみが変更されます。

1. RAX (x64) および EDX: EAX (x86) は、常にハイパーコール result 値と出力パラメーター (存在する場合) で上書きされます。
1. Rep (x64) および EDX: EAX (x86) は、新しい rep 開始インデックスを使用して変更されます。
1. [HvCallSetVpRegisters](./hypercalls/HvCallSetVpRegisters.md) は、そのハイパーコールでサポートされているすべてのレジスタを変更できます。
1. RDX、R8、および XMM0 から XMM5 までの高速なハイパーコール入力の場合は、変更されません。 ただし、高速ハイパーコール出力に使用されるレジスタは、RDX、R8、XMM0 を通じて XMM5 を含む変更できます。 Hyper-v では、これらのレジスタを変更するだけで高速ハイパーコール出力が行われます。これは、x64 に限定されます。

## <a name="hypercall-restrictions"></a>ハイパーコールの制限

ハイパーコールには、目的の機能を実行するために、関連する制限が関連付けられている場合があります。 すべての制限が満たされていない場合、ハイパーコールは適切なエラーで終了します。 適用される場合は、次の制限事項が表示されます。

- 呼び出し元パーティションには特定の特権が必要です。
- 操作対象のパーティションは、特定の状態 ("アクティブ" など) である必要があります。

## <a name="hypercall-status-codes"></a>ハイパーコールの状態コード

各ハイパーコールは、いくつかのフィールドを含む出力値を返すように記述されています。 状態値フィールド (型 `HV_STATUS` ) は、呼び出しが成功したか失敗したかを示すために使用されます。

### <a name="output-parameter-validity-on-failed-hypercalls"></a>失敗したハイパーコールの出力パラメーターの有効性

明示的に指定されていない限り、ハイパーコールが失敗した場合 (ハイパーコール結果値の結果フィールドに以外の値が含まれている場合 `HV_STATUS_SUCCESS` )、すべての出力パラメーターの内容は不確定であり、呼び出し元によって検査される必要はありません。 ハイパーコールが成功した場合にのみ、適切なすべての出力パラメーターに有効な結果が含まれます。

### <a name="ordering-of-error-conditions"></a>エラー条件の順序

ハイパーバイザーによってエラー状態が検出され、報告される順序は定義されていません。 つまり、複数のエラーが存在する場合、ハイパーバイザーは、報告するエラー条件を選択する必要があります。 これらのエラーコードには優先順位を付ける必要があります。セキュリティを強化するために、十分な特権を持たない呼び出し元に情報が漏洩するのを防ぐことを目的としています。 たとえば、状態コードは、 `HV_STATUS_ACCESS_DENIED` 特権に基づいて純粋にコンテキストまたは状態情報を表示する優先ステータスコードです。

### <a name="common-hypercall-status-codes"></a>一般的なハイパーコールの状態コード

いくつかの結果コードは、すべてのハイパーコールに共通であるため、ハイパーコールごとに個別に記載されているわけではありません。 これらには、次のものが含まれます。

| status code                        | エラー状態                                                                       |
|------------------------------------|---------------------------------------------------------------------------------------|
| `HV_STATUS_SUCCESS`                | 呼び出しは成功しました。                                                                   |
| `HV_STATUS_INVALID_HYPERCALL_CODE` | ハイパーコールコードが認識されません。                                                 |
| `HV_STATUS_INVALID_HYPERCALL_INPUT`| Rep カウントが正しくありません (たとえば、0以外の担当者数が非営業担当者の電話に渡されたか、担当者の電話に0の担当者数が渡された場合など)。
|                                    | Rep 開始インデックスが rep カウントより小さくありません。                                   |
|                                    | 指定されたハイパーコール入力値の予約ビットが0以外です。                    |
| `HV_STATUS_INVALID_ALIGNMENT`      | 指定された入力または出力 GPA ポインターが8バイトにアラインされていません。                  |
|                                    | 指定された入力パラメーターまたは出力パラメーターによって複数のページが表示されます。                            |
|                                    | Input または output GPA ポインターが GPA space の範囲内にありません。            |

リターンコードは、 `HV_STATUS_SUCCESS` エラー状態が検出されなかったことを示します。

## <a name="reporting-the-guest-os-identity"></a>ゲスト OS Id を報告する

パーティション内で実行されているゲスト OS は、署名とバージョンを MSR () に書き込んで、ハイパーバイザーを呼び出すことができるようにする必要があり `HV_X64_MSR_GUEST_OS_ID` ます。 この MSR はパーティション全体で、すべての仮想プロセッサ間で共有されます。

このレジスタの値は、最初は0です。 ハイパーコールコードページを有効にする前に、0以外の値をゲスト OS ID MSR に書き込む必要があります (「 [ハイパーコールインターフェイスの確立](#establishing-the-hypercall-interface)」を参照してください)。 その後、このレジスタがゼロに設定されると、ハイパーコールコードページは無効になります。

 ```c
#define HV_X64_MSR_GUEST_OS_ID 0x40000000
 ```

### <a name="guest-os-identity-for-proprietary-operating-systems"></a>独自のオペレーティングシステムのゲスト OS Id

次に、この MSR に推奨されるエンコードを示します。 一部のゲスト Os では、一部のフィールドが適用されない場合があります。

| Bits      | フィールド           | 説明                                                                 |
|-----------|-----------------|-----------------------------------------------------------------------------|
| 15:0      | ビルド番号    | OS のビルド番号を示します。                                        |
| 23:16     | サービスのバージョン | サービスのバージョンを示します (例、"Service Pack")          |
| 31:24     | マイナー バージョン   | OS のマイナーバージョンを示します。                                       |
| 39:32     | メジャー バージョン   | OS のメジャーバージョンを示します。                                       |
| 47:40     | OS ID           | OS のバリエーションを示します。 エンコーディングはベンダーに固有です。 Microsoft オペレーティングシステムは次のようにエンコードされます。 0 = Undefined、1 = MS-DOS®、2 = Windows®3.x、3 = Windows®9x、4 = Windows® NT (および導関数)、5 = Windows® CE
| 62:48     | ベンダ ID       | ゲスト OS ベンダを示します。 値0は予約されています。 以下のベンダーの一覧を参照してください。
| 63        | OS の種類         | OS の種類を示します。 値が0の場合は、専用の閉じたソース OS が示されます。 値1は、オープンソースの OS を示します。

仕入先の値は、Microsoft によって割り当てられます。 新しいベンダを申請するには、GitHub virtualization documentation repository () に問題を報告してください <https://aka.ms/VirtualizationDocumentationIssuesTLFS> 。

| ベンダー    | 値                                                                                |
|-----------|--------------------------------------------------------------------------------------|
| Microsoft | 0x0001                                                                               |
| HPE       | 0x0002                                                                               |
| LANCOM    | 0x0200                                                                               |

### <a name="guest-os-identity-msr-for-open-source-operating-systems"></a>オープンソースのオペレーティングシステム用のゲスト OS Id MSR

次のエンコーディングは、この仕様に準拠することを目的とした、オープンソースのオペレーティングシステムベンダー向けのガイダンスとして提供されています。 オープンソースのオペレーティングシステムでは、次の規則を適合させることをお勧めします。

| Bits      | フィールド           | 説明                                                                 |
|-----------|-----------------|-----------------------------------------------------------------------------|
| 15:0      | ビルド番号    | 追加情報                                                      |
| 47:16     | Version         | アップストリームカーネルのバージョン情報。                                        |
| 55:48     | OS ID           | 追加のベンダー情報                                               |
| 62:56     | OS の種類         | OS の種類 (例: Linux、FreeBSD など)。 以下の既知の OS の種類の一覧を参照してください      |
| 63        | オープン ソース     | 値1は、オープンソースの OS を示します。                                   |

OS の種類の値は、Microsoft によって割り当てられます。 新しい OS の種類を要求するには、GitHub 仮想化ドキュメントリポジトリ () で問題を報告してください <https://aka.ms/VirtualizationDocumentationIssuesTLFS> 。

| OS の種類   | 値                                                                                |
|-----------|--------------------------------------------------------------------------------------|
| Linux     | 0x1                                                                                  |
| FreeBSD   | 0x2                                                                                  |
| Xen       | 0x3                                                                                  |
| Illumos   | 0x4                                                                                  |

## <a name="establishing-the-hypercall-interface"></a>ハイパーコールインターフェイスの確立

ハイパーコールは特殊なオペコードを使用して呼び出されます。 このオペコードは仮想化実装によって異なるため、ハイパーバイザーでこの違いを抽象化する必要があります。 これは、特殊なハイパーコールページを使用して行います。 このページはハイパーバイザーによって提供され、ゲストの GPA 領域内に表示されます。 ゲストは、ゲストハイパーコール MSR をプログラミングすることによって、ページの場所を指定する必要があります。

 ```c
#define HV_X64_MSR_HYPERCALL 0x40000001
 ```

| Bits    | 説明                                                                        | 属性      |
|---------|------------------------------------------------------------------------------------|-----------------|
| 63:12   | ハイパーコール GPFN-ハイパーコールページのゲスト物理ページ番号を示します。    | 読み取り/書き込み    |
| 11:2    | RsvdP. 読み取り時には Bits を無視し、書き込み時には保持する必要があります。                    | 予約済み        |
| 1       | た. MSR が不変であるかどうかを示します。 設定すると、この MSR はロックされるため、ハイパーコールページを再配置できなくなります。 一度設定すると、システムのリセットだけがビットをクリアできます。                                                    | 読み取り/書き込み    |
| 0       | [ハイパーコールの有効化] ページ                                                              | 読み取り/書き込み    |

ハイパーコールページは、ゲストの GPA 領域内の任意の場所に配置できますが、ページ上に配置する必要があります。 ゲストがハイパーコールページを GPA 領域の境界を越えて移動しようとすると、MSR の書き込み時に #GP フォールトが発生します。

この MSR は、パーティション全体の MSR です。 つまり、パーティション内のすべての仮想プロセッサによって共有されます。 1つの仮想プロセッサが MSR に正常に書き込みを行うと、別の仮想プロセッサが同じ値を読み取ります。

ハイパーコールページが有効になる前に、ゲスト OS はバージョンの署名を別の MSR (HV_X64_MSR_GUEST_OS_ID) に書き込んで、id を報告する必要があります。 ゲスト OS id が指定されていない場合、ハイパーコールを有効にしようとすると失敗します。 Enable ビットは、1つのが書き込まれていても0のままになります。 さらに、ハイパーコールページが有効になった後にゲスト OS id がゼロにクリアされると、無効になります。

ハイパーコールページは、GPA space に "オーバーレイ" として表示されます。つまり、GPA の範囲に割り当てられている他のすべてのものが対象となります。 その内容は、ゲストが読み取ることができ、実行可能ファイルです。 ハイパーコールページへの書き込みが試行されると、保護 (#GP) 例外が発生します。 ハイパーコールページを有効にした後、ハイパーコールを呼び出すと、単にページの先頭を呼び出すことができます。

次に、ハイパーコールページの確立に関連する手順の詳細を示します。

1. ゲストは、CPUID リーフ1を読み取り、登録 ECX のビット31をチェックすることによってハイパーバイザーが存在するかどうかを判断します。
2. ゲストは、(レジスタ eax で返される) 最大ハイパーバイザー CPUID リーフ (レジスタ EAX で返される) と CPUID リーフ 0x40000001 (レジスタ EAX で返される) を判断するために、CPUID リーフ0x40000000 を読み取ります。 最大のリーフ値が0x40000005 以上であり、インターフェイスシグネチャが "Hv # 1" と等しいことを確認します。 このシグネチャ `HV_X64_MSR_GUEST_OS_ID` は、、 `HV_X64_MSR_HYPERCALL` およびが実装されていることを意味し `HV_X64_MSR_VP_INDEX` ます。
3. ゲストは、そのレジスタがゼロの場合、OS id を MSR に書き込み `HV_X64_MSR_GUEST_OS_ID` ます。
4. ゲストは、ハイパーコール MSR () を読み取り `HV_X64_MSR_HYPERCALL` ます。
5. ゲストは、Enable ハイパーコールページビットを確認します。 設定されている場合は、インターフェイスが既にアクティブになっており、手順6と7を省略する必要があります。
6. ゲストは、GPA 領域内のページを検索します。これは、RAM や MMIO などによって占有されていないページです。 ページが占有されている場合、ゲストは、他の目的で基になるページを使用しないようにする必要があります。
7. ゲストは、手順6の GPA を含むハイパーコール MSR () に新しい値を書き込み、 `HV_X64_MSR_HYPERCALL` Enable ハイパーコール Page ビットを設定して、インターフェイスを有効にします。
8. ゲストは、ハイパーコールページ GPA に対する実行可能ファイル VA マッピングを作成します。
9. ゲストは CPUID リーフ0x40000003 を参照して、使用可能なハイパーバイザー機能を特定します。
インターフェイスが確立されると、ゲストはハイパーコールを開始できます。 これを行うには、ハイパーコールプロトコルごとにレジスタを設定し、ハイパーコールページの先頭に呼び出しを発行します。 ゲストは、ハイパーコールページが呼び出し元に戻るために、near 戻り値 (0xC3) と同等のものを実行すると想定する必要があります。 そのため、有効なスタックを使用してハイパーコールを呼び出す必要があります。

## <a name="extended-hypercall-interface"></a>拡張ハイパーコールインターフェイス

0x8000 を超える呼び出しコードを使用したハイパーコールは、拡張ハイパーコールと呼ばれます。 拡張ハイパーコールは、通常のハイパーコールと同じ呼び出し規約を使用し、ゲスト VM の観点と同じように見えます。 拡張ハイパースレッディングの内部では、Hyper-v ハイパーバイザー内で異なる方法で処理されます。

拡張ハイパーコール機能は、 [Hvextcallquerycapabilities](hypercalls/HvExtCallQueryCapabilities.md)でクエリを実行できます。